---
title: Binary Exploiting (pwn)
category: Exploiting
order: 2
---

# Tools Usage

## ltrace

`ltrace` is a program that simply runs the specified command until it exits. It intercepts and records the dynamic library calls which are executed.

```
$ ltrace ./login 
__libc_start_main(0x8049192, 1, 0xff8f56d4, 0x8049260 <unfinished ...>
puts("Enter admin password: "Enter admin password: 
)                                                   = 23
gets(0xff8f55f6, 0xf7f808cb, 0xf7d3fa2f, 0x80491a9password
)                              = 0xff8f55f6
strcmp("password", "pass")                                                       = 1
puts("Incorrect Password!"Incorrect Password!
)                                                      = 20
printf("Successfully logged in as Admin "..., 25714Successfully logged in as Admin (authorised=25714) :)
)                             = 54
+++ exited (status 0) +++
```
As you can see the binary compares my password `password` with `pass` which should be the admin password.

## Ghidra (Decompiler + Disassembler)

`Ghidra` is a very useful tool to decompile the binary and obtain a close version of the source code.

![Ghidra](/hackingnotes/images/ghidra.png)


## GDB + Peda + Pwndbg (Debugger + Disassembler)

Once installed and configured we just need to launch `gdb`.

* [https://infosecwriteups.com/pwndbg-gef-peda-one-for-all-and-all-for-one-714d71bf36b8](https://infosecwriteups.com/pwndbg-gef-peda-one-for-all-and-all-for-one-714d71bf36b8)

```
$ gdb-peda
gdb-peda$

$ gdb-pwndbg                                                                        
pwndbg> 
```

### Opening the file

First we need to select the binary.

```
gdb-peda$ file ./vuln
Reading symbols from ./vuln...
(No debugging symbols found in ./vuln)
```

### Check functions

We can see what function are in there.

```
gdb-peda$ info functions
All defined functions:

Non-debugging symbols:
0x08049000  _init
0x08049030  gets@plt
0x08049040  puts@plt
0x08049050  __libc_start_main@plt
0x08049060  _start
0x080490a0  _dl_relocate_static_pie
0x080490b0  __x86.get_pc_thunk.bx
0x080490c0  deregister_tm_clones
0x08049100  register_tm_clones
0x08049140  __do_global_dtors_aux
0x08049170  frame_dummy
0x08049172  main
0x080491c0  __libc_csu_init
0x08049220  __libc_csu_fini
0x08049221  __x86.get_pc_thunk.bp
0x08049228  _fini
```

### Disassemble a function

`gdb` can also disassemble a function.

```
gdb-peda$ disassemble main
Dump of assembler code for function main:
   0x08049192 <+0>:     lea    ecx,[esp+0x4]
   0x08049196 <+4>:     and    esp,0xfffffff0
   0x08049199 <+7>:     push   DWORD PTR [ecx-0x4]
   0x0804919c <+10>:    push   ebp
   0x0804919d <+11>:    mov    ebp,esp
   0x0804919f <+13>:    push   ebx
   0x080491a0 <+14>:    push   ecx
   0x080491a1 <+15>:    sub    esp,0x10
```

### Set breakpoints

We can set breakpoints in execution to stop the program in a function.

```
gdb-peda$ break main
Breakpoint 1 at 0x8049181
```
Or we can set a breakpoint in a address using the hex value or the ascii value.

```
gdb-peda$ break *0x804921e
Breakpoint 2 at 0x804921e
```

```
gdb-peda$ break *main+140
Breakpoint 1 at 0x804921e
```

We can also delete breakpoints

```
gdb-peda$ delete breakpoints
```
To move between instructions we can use `n` to go next, and `c` to continue.

### Run the program

```
gdb-peda$ run
```

### Stack Info

We can also retrieve which data is stored on the stack.

```
gdb-peda$ info stack
#0  0x08049181 in main ()
#1  0xf7dd4fd6 in __libc_start_main () from /lib/i386-linux-gnu/libc.so.6
#2  0x08049092 in _start ()
```

## Pwntools

`pwn` is a python library that is designed to create exploits.

```python
from pwn import *
```

* Exploiting local files:

In order to start a program we need to use `process` function.

```python
io = process('./file')
```
* Connecting remotely

```python
io = remote('10.10.10.10', 80)
```
* Recieve line:

```python
io.recvline()
```
* Send payload:

```python
io.send(b'PAYLOAD\r\n')
```

* Send String after a char:

```python
io.sendlineafter(b':', b'PAYLOAD')
```

* Recieve output:

```python
io.recvall().decode()
```


# Check Architecture

With file we can check with which architecture we are going to work.
```
$ file vuln                                     
vuln: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=c5631a370f7704c44312f6692e1da56c25c1863c, not stripped
```
# Binary Security

`checksec` is very usefull to see what defenses are enabled in the compiled binary.

```
$ checksec vuln                                 
[*] '/tmp/vuln'
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

* **Address Space Layout Randomization (ASLR)**: ASLR is the randomization of the place in memory where the program, shared libraries, the stack, and the heap are. This makes can make it harder for an attacker to exploit a service, as knowledge about where the stack, heap, or libc can't be re-used between program launches. This is a partially effective way of preventing an attacker from jumping to, for example, libc without a leak.

* **RELRO**: Relocation Read-Only is a security measure which makes some binary sections read-only. There are two RELRO modes, partial and full. **Partial RELRO** is the default setting in gcc, eliminates the risk of a BOF on a global variable overwriting Global Offset Table (GOT) entries. **Full RELRO** makes the entire GOT read-only which removes the ability to perform a "GOT overwirte" attack.

* **Stack Canaries**: Stack Canaries are a secret value placed on the stack which changes every time the program is started. Prior to a function return, the stack canary is checked and if it appears to be modified, the program exits immeadiately. Stack Canaries seem like a clear cut way to mitigate any stack smashing as it is fairly impossible to just guess a random 64-bit value. However, leaking the address and bruteforcing the canary are two methods which would allow us to get through the canary check.

* **No eXecute (NX)**: The No eXecute or the NX bit (also known as Data Execution Prevention or DEP) marks certain areas of the program as not executable, meaning that stored input or data cannot be executed as code. This is significant because it prevents attackers from being able to jump to custom shellcode that they've stored on the stack or in a global variable.

* **Position Independent Executable (PIE)**: Every time the file is runned it gets loaded into a different memory address. This means that you cannot hardcode values such as function addresses and gadget locations without finding out where they are.

## Compile with no protections

If we have the source code (C), we can compile it with any protection.

```bash
gcc vuln.c -o vuln -fno-stack-protector -z execstack -no-pie -m32
```

